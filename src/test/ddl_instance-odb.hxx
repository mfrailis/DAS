// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#ifndef DDL_INSTANCE_ODB_HXX
#define DDL_INSTANCE_ODB_HXX

#include <odb/version.hxx>

#if (ODB_VERSION != 20100UL)
#error ODB runtime version mismatch
#endif

#include <odb/pre.hxx>

// Begin prologue.
//
#include <odb/boost/version.hxx>
#if ODB_BOOST_VERSION != 2010000 // 2.1.0
#  error ODB and C++ compilers see different libodb-boost interface versions
#endif
#include <odb/boost/date-time/mysql/posix-time-traits.hxx>
//
// End prologue.

#include "ddl_instance.hxx"

#include <memory>
#include <cstddef>

#include <odb/core.hxx>
#include <odb/traits.hxx>
#include <odb/callback.hxx>
#include <odb/wrapper-traits.hxx>
#include <odb/pointer-traits.hxx>
#include <odb/tr1/wrapper-traits.hxx>
#include <odb/tr1/pointer-traits.hxx>
#include <odb/container-traits.hxx>
#include <odb/cache-traits.hxx>
#include <odb/result.hxx>
#include <odb/simple-object-result.hxx>

#include <odb/details/buffer.hxx>
#include <odb/details/unused.hxx>

#include <odb/mysql/version.hxx>
#include <odb/mysql/forward.hxx>
#include <odb/mysql/binding.hxx>
#include <odb/mysql/mysql-types.hxx>
#include <odb/mysql/query.hxx>

namespace odb
{
  // EssentialMetadata
  //
  template <>
  struct class_traits< ::EssentialMetadata >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::EssentialMetadata, A >
  {
    // name
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    name_type_;

    static const name_type_ name;

    // version
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        short int,
        mysql::id_short >::query_type,
      mysql::id_short >
    version_type_;

    static const version_type_ version;

    // dbUserId
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    dbUserId_type_;

    static const dbUserId_type_ dbUserId;

    // creationDate
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    creationDate_type_;

    static const creationDate_type_ creationDate;
  };

  template <typename A>
  const typename query_columns< ::EssentialMetadata, A >::name_type_
  query_columns< ::EssentialMetadata, A >::
  name (A::table_name, "`name`", 0);

  template <typename A>
  const typename query_columns< ::EssentialMetadata, A >::version_type_
  query_columns< ::EssentialMetadata, A >::
  version (A::table_name, "`version`", 0);

  template <typename A>
  const typename query_columns< ::EssentialMetadata, A >::dbUserId_type_
  query_columns< ::EssentialMetadata, A >::
  dbUserId (A::table_name, "`dbUserId`", 0);

  template <typename A>
  const typename query_columns< ::EssentialMetadata, A >::creationDate_type_
  query_columns< ::EssentialMetadata, A >::
  creationDate (A::table_name, "`creationDate`", 0);

  template <typename A>
  struct pointer_query_columns< ::EssentialMetadata, A >:
    query_columns< ::EssentialMetadata, A >
  {
  };

  template <>
  class access::object_traits< ::EssentialMetadata >
  {
    public:
    typedef ::EssentialMetadata object_type;
    typedef ::std::tr1::shared_ptr< ::EssentialMetadata > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    static const bool abstract = true;

    struct image_type
    {
      // name_
      //
      details::buffer name_value;
      unsigned long name_size;
      my_bool name_null;

      // version_
      //
      short version_value;
      my_bool version_null;

      // dbUserId_
      //
      details::buffer dbUserId_value;
      unsigned long dbUserId_size;
      my_bool dbUserId_null;

      // creationDate_
      //
      MYSQL_TIME creationDate_value;
      my_bool creationDate_null;
    };

    static bool
    grow (image_type&, my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static bool
    init (image_type&, const object_type&, mysql::statement_kind);

    static void
    init (object_type&, const image_type&, database*);
  };

  // LfiDaeSlowVoltageColumn
  //
  template <>
  struct class_traits< ::LfiDaeSlowVoltageColumn >
  {
    static const class_kind kind = class_composite;
  };

  template <>
  class access::composite_value_traits< ::LfiDaeSlowVoltageColumn >
  {
    public:
    typedef ::LfiDaeSlowVoltageColumn value_type;

    struct image_type
    {
      // size_
      //
      long long size_value;
      my_bool size_null;

      // type_
      //
      details::buffer type_value;
      unsigned long type_size;
      my_bool type_null;

      // fname_
      //
      details::buffer fname_value;
      unsigned long fname_size;
      my_bool fname_null;
    };

    static bool
    grow (image_type&, my_bool*);

    static void
    bind (MYSQL_BIND*, image_type&, mysql::statement_kind);

    static bool
    init (image_type&, const value_type&, mysql::statement_kind);

    static void
    init (value_type&, const image_type&, database*);

    static bool
    get_null (const image_type&);

    static void
    set_null (image_type&, mysql::statement_kind);
  };

  // LfiDaeSlowVoltage
  //
  template <>
  struct class_traits< ::LfiDaeSlowVoltage >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::LfiDaeSlowVoltage, A >:
    query_columns< ::EssentialMetadata, A >
  {
    // EssentialMetadata
    //
    typedef query_columns< ::EssentialMetadata, A > EssentialMetadata;

    // das_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long long int,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    das_id_type_;

    static const das_id_type_ das_id;

    // relative_path
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    relative_path_type_;

    static const relative_path_type_ relative_path;

    // runId
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    runId_type_;

    static const runId_type_ runId;

    // startTime
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long long int,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    startTime_type_;

    static const startTime_type_ startTime;

    // endTime
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long long int,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    endTime_type_;

    static const endTime_type_ endTime;

    // apid
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        short int,
        mysql::id_short >::query_type,
      mysql::id_short >
    apid_type_;

    static const apid_type_ apid;

    // type
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        char,
        mysql::id_tiny >::query_type,
      mysql::id_tiny >
    type_type_;

    static const type_type_ type;

    // subtype
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        char,
        mysql::id_tiny >::query_type,
      mysql::id_tiny >
    subtype_type_;

    static const subtype_type_ subtype;

    // pi1Val
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        short int,
        mysql::id_short >::query_type,
      mysql::id_short >
    pi1Val_type_;

    static const pi1Val_type_ pi1Val;

    // pi2Val
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        short int,
        mysql::id_short >::query_type,
      mysql::id_short >
    pi2Val_type_;

    static const pi2Val_type_ pi2Val;
  };

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::das_id_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  das_id (A::table_name, "`das_id`", 0);

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::relative_path_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  relative_path (A::table_name, "`relative_path`", 0);

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::runId_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  runId (A::table_name, "`runId`", 0);

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::startTime_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  startTime (A::table_name, "`startTime`", 0);

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::endTime_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  endTime (A::table_name, "`endTime`", 0);

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::apid_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  apid (A::table_name, "`apid`", 0);

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::type_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  type (A::table_name, "`type`", 0);

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::subtype_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  subtype (A::table_name, "`subtype`", 0);

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::pi1Val_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  pi1Val (A::table_name, "`pi1Val`", 0);

  template <typename A>
  const typename query_columns< ::LfiDaeSlowVoltage, A >::pi2Val_type_
  query_columns< ::LfiDaeSlowVoltage, A >::
  pi2Val (A::table_name, "`pi2Val`", 0);

  template <typename A>
  struct pointer_query_columns< ::LfiDaeSlowVoltage, A >:
    query_columns< ::LfiDaeSlowVoltage, A >
  {
  };

  template <>
  class access::object_traits< ::LfiDaeSlowVoltage >
  {
    public:
    typedef ::LfiDaeSlowVoltage object_type;
    typedef ::std::tr1::shared_ptr< ::LfiDaeSlowVoltage > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long long int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type: object_traits< ::EssentialMetadata >::image_type
    {
      // das_id_
      //
      long long das_id_value;
      my_bool das_id_null;

      // relative_path_
      //
      details::buffer relative_path_value;
      unsigned long relative_path_size;
      my_bool relative_path_null;

      // runId_
      //
      details::buffer runId_value;
      unsigned long runId_size;
      my_bool runId_null;

      // startTime_
      //
      long long startTime_value;
      my_bool startTime_null;

      // endTime_
      //
      long long endTime_value;
      my_bool endTime_null;

      // apid_
      //
      short apid_value;
      my_bool apid_null;

      // type_
      //
      signed char type_value;
      my_bool type_null;

      // subtype_
      //
      signed char subtype_value;
      my_bool subtype_null;

      // pi1Val_
      //
      short pi1Val_value;
      my_bool pi1Val_null;

      // pi2Val_
      //
      short pi2Val_value;
      my_bool pi2Val_null;

      std::size_t version;
    };

    // columns_
    //
    struct columns_traits
    {
      static const std::size_t id_column_count = 1UL;
      static const std::size_t cond_column_count = 1UL;
      static const std::size_t data_column_count = 5UL;

      static const char insert_one_statement[];
      static const char select_all_statement[];
      static const char delete_all_statement[];

      typedef ::std::map< ::std::basic_string< char >, ::LfiDaeSlowVoltageColumn > container_type;
      typedef
      odb::access::container_traits<container_type>
      container_traits_type;
      typedef container_traits_type::key_type key_type;
      typedef container_traits_type::value_type value_type;

      typedef map_functions<key_type, value_type> functions_type;
      typedef mysql::container_statements< columns_traits > statements_type;

      struct cond_image_type
      {
        // key
        //
        details::buffer key_value;
        unsigned long key_size;
        my_bool key_null;

        std::size_t version;
      };

      struct data_image_type
      {
        // key
        //
        details::buffer key_value;
        unsigned long key_size;
        my_bool key_null;

        // value
        //
        composite_value_traits< value_type >::image_type value_value;

        std::size_t version;
      };

      static void
      bind (MYSQL_BIND*,
            const MYSQL_BIND* id,
            std::size_t id_size,
            cond_image_type&);

      static void
      bind (MYSQL_BIND*,
            const MYSQL_BIND* id,
            std::size_t id_size,
            data_image_type&);

      static void
      grow (data_image_type&, my_bool*);

      static void
      init (data_image_type&, const key_type&, const value_type&);

      static void
      init (key_type&, value_type&, const data_image_type&, database*);

      static void
      insert_one (const key_type&, const value_type&, void*);

      static bool
      load_all (key_type&, value_type&, void*);

      static void
      delete_all (void*);

      static void
      persist (const container_type&,
               const mysql::binding& id,
               statements_type&);

      static void
      load (container_type&,
            const mysql::binding& id,
            statements_type&);

      static void
      update (const container_type&,
              const mysql::binding& id,
              statements_type&);

      static void
      erase (const mysql::binding& id, statements_type&);
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&, const object_type&, mysql::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 14UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // TestLogImage
  //
  template <>
  struct class_traits< ::TestLogImage >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::TestLogImage, A >:
    query_columns< ::EssentialMetadata, A >
  {
    // EssentialMetadata
    //
    typedef query_columns< ::EssentialMetadata, A > EssentialMetadata;

    // das_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long long int,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    das_id_type_;

    static const das_id_type_ das_id;

    // naxis1
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    naxis1_type_;

    static const naxis1_type_ naxis1;

    // naxis2
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    naxis2_type_;

    static const naxis2_type_ naxis2;

    // format
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    format_type_;

    static const format_type_ format;
  };

  template <typename A>
  const typename query_columns< ::TestLogImage, A >::das_id_type_
  query_columns< ::TestLogImage, A >::
  das_id (A::table_name, "`das_id`", 0);

  template <typename A>
  const typename query_columns< ::TestLogImage, A >::naxis1_type_
  query_columns< ::TestLogImage, A >::
  naxis1 (A::table_name, "`naxis1`", 0);

  template <typename A>
  const typename query_columns< ::TestLogImage, A >::naxis2_type_
  query_columns< ::TestLogImage, A >::
  naxis2 (A::table_name, "`naxis2`", 0);

  template <typename A>
  const typename query_columns< ::TestLogImage, A >::format_type_
  query_columns< ::TestLogImage, A >::
  format (A::table_name, "`format`", 0);

  template <typename A>
  struct pointer_query_columns< ::TestLogImage, A >:
    query_columns< ::TestLogImage, A >
  {
  };

  template <>
  class access::object_traits< ::TestLogImage >
  {
    public:
    typedef ::TestLogImage object_type;
    typedef ::std::tr1::shared_ptr< ::TestLogImage > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long long int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type: object_traits< ::EssentialMetadata >::image_type
    {
      // das_id_
      //
      long long das_id_value;
      my_bool das_id_null;

      // naxis1_
      //
      int naxis1_value;
      my_bool naxis1_null;

      // naxis2_
      //
      int naxis2_value;
      my_bool naxis2_null;

      // format_
      //
      details::buffer format_value;
      unsigned long format_size;
      my_bool format_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&, const object_type&, mysql::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 8UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // TestLog
  //
  template <>
  struct class_traits< ::TestLog >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::TestLog, A >:
    query_columns< ::EssentialMetadata, A >
  {
    // EssentialMetadata
    //
    typedef query_columns< ::EssentialMetadata, A > EssentialMetadata;

    // das_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long long int,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    das_id_type_;

    static const das_id_type_ das_id;

    // runId
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    runId_type_;

    static const runId_type_ runId;

    // startTime
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long long int,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    startTime_type_;

    static const startTime_type_ startTime;

    // endTime
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long long int,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    endTime_type_;

    static const endTime_type_ endTime;

    // log
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    log_type_;

    static const log_type_ log;
  };

  template <typename A>
  const typename query_columns< ::TestLog, A >::das_id_type_
  query_columns< ::TestLog, A >::
  das_id (A::table_name, "`das_id`", 0);

  template <typename A>
  const typename query_columns< ::TestLog, A >::runId_type_
  query_columns< ::TestLog, A >::
  runId (A::table_name, "`runId`", 0);

  template <typename A>
  const typename query_columns< ::TestLog, A >::startTime_type_
  query_columns< ::TestLog, A >::
  startTime (A::table_name, "`startTime`", 0);

  template <typename A>
  const typename query_columns< ::TestLog, A >::endTime_type_
  query_columns< ::TestLog, A >::
  endTime (A::table_name, "`endTime`", 0);

  template <typename A>
  const typename query_columns< ::TestLog, A >::log_type_
  query_columns< ::TestLog, A >::
  log (A::table_name, "`log`", 0);

  template <typename A>
  struct pointer_query_columns< ::TestLog, A >:
    query_columns< ::TestLog, A >
  {
  };

  template <>
  class access::object_traits< ::TestLog >
  {
    public:
    typedef ::TestLog object_type;
    typedef ::std::tr1::shared_ptr< ::TestLog > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long long int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type: object_traits< ::EssentialMetadata >::image_type
    {
      // das_id_
      //
      long long das_id_value;
      my_bool das_id_null;

      // runId_
      //
      details::buffer runId_value;
      unsigned long runId_size;
      my_bool runId_null;

      // startTime_
      //
      long long startTime_value;
      my_bool startTime_null;

      // endTime_
      //
      long long endTime_value;
      my_bool endTime_null;

      // log_
      //
      details::buffer log_value;
      unsigned long log_size;
      my_bool log_null;

      std::size_t version;
    };

    // images_
    //
    struct images_traits
    {
      static const std::size_t id_column_count = 1UL;
      static const std::size_t cond_column_count = 1UL;
      static const std::size_t data_column_count = 2UL;

      static const char insert_one_statement[];
      static const char select_all_statement[];
      static const char delete_all_statement[];

      typedef ::std::vector< ::odb::tr1::lazy_shared_ptr< ::TestLogImage > > container_type;
      typedef
      odb::access::container_traits<container_type>
      container_traits_type;
      typedef container_traits_type::index_type index_type;
      typedef container_traits_type::value_type value_type;

      typedef ordered_functions<index_type, value_type> functions_type;
      typedef mysql::container_statements< images_traits > statements_type;

      struct cond_image_type
      {
        std::size_t version;
      };

      struct data_image_type
      {
        // value
        //
        long long value_value;
        my_bool value_null;

        std::size_t version;
      };

      static void
      bind (MYSQL_BIND*,
            const MYSQL_BIND* id,
            std::size_t id_size,
            cond_image_type&);

      static void
      bind (MYSQL_BIND*,
            const MYSQL_BIND* id,
            std::size_t id_size,
            data_image_type&);

      static void
      grow (data_image_type&, my_bool*);

      static void
      init (data_image_type&, const value_type&);

      static void
      init (value_type&, const data_image_type&, database*);

      static void
      insert_one (index_type, const value_type&, void*);

      static bool
      load_all (index_type&, value_type&, void*);

      static void
      delete_all (void*);

      static void
      persist (const container_type&,
               const mysql::binding& id,
               statements_type&);

      static void
      load (container_type&,
            const mysql::binding& id,
            statements_type&);

      static void
      update (const container_type&,
              const mysql::binding& id,
              statements_type&);

      static void
      erase (const mysql::binding& id, statements_type&);
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&, const object_type&, mysql::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 9UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };
}

#include "ddl_instance-odb.ixx"

#include <odb/post.hxx>

#endif // DDL_INSTANCE_ODB_HXX
